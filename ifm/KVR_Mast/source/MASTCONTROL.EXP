
(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Steuerung' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MastControl
VAR_INPUT
	init: BOOL;
END_VAR
VAR
	status: BYTE := STATUS_INIT;
	masthoeheReal: REAL;
	masthoeheSchleichfahrt: WORD;
	masthoeheEndschalter: WORD;
	masthoeheAbsetzen: WORD;
	mastPosGueltig: BOOL := FALSE;
	TSStart: DWORD;
	rtTasteReset: R_TRIG;
	rtSystemEin: R_TRIG;
	tonSystemEin: TON;
	tonKompressor: TON;
	tofInit: TOF;
	blnk: BLINK;
	SDOData: ARRAY[0..3] OF BYTE;
	SDOWriteOffset: CANOPEN_SDOWRITE;
	errorCode71x: BOOL;
END_VAR
VAR CONSTANT
	_100ms: DWORD := 100000;
	STATUS_INIT: 					BYTE := 0;
	STATUS_WAIT_FOR_CAN_CLIENTS: 	BYTE := 10;
	STATUS_SETUP_OFFSET: 			BYTE := 11;
	STATUS_WRITE_OFFSET: 			BYTE := 12;
	STATUS_SUCCESS: 				BYTE := 15;
	STATUS_NULLFAHRT_AUSFAHREN: 	BYTE := 20;
	STATUS_NULLFAHRT_EINFAHREN: 	BYTE := 21;
	STATUS_NULLPUNKT_SETZEN_INIT: 	BYTE := 30;
	STATUS_NULLPUNKT_SETZEN: 		BYTE := 31;
	STATUS_IDLE: 					BYTE := 50;
	STATUS_AUSFAHREN: 				BYTE := 60;
	STATUS_AUSFAHREN_ES_SUCHEN: 	BYTE := 61;
	STATUS_ABSETZEN_INIT:			BYTE := 63;
	STATUS_ABSETZEN: 				BYTE := 64;
	STATUS_AUSGEFAHREN: 			BYTE := 65;
	STATUS_AUSFAHREN_MONTAGE: 		BYTE := 66;
	STATUS_MONTAGEPOSITION: 		BYTE := 67;
	STATUS_EINFAHREN: 				BYTE := 70;
	STATUS_SCHLEICHFAHRT_ES_SUCHEN: BYTE := 71;
	STATUS_SCHLEICHFAHRT: 			BYTE := 72;
	STATUS_EINGEFAHREN: 			BYTE := 73;

	(* Ständige Überprüfungen *)
	STATUS_ERR_FU_TIMEOUT: 			BYTE := 100; (* FU nicht (mehr) online *)
	STATUS_ERR_CURRENT: 			BYTE := 101; (* Hoher Grenzwert Strom überschritten *)
	STATUS_ERR_FU: 					BYTE := 102; (* FU meldet Fehler *)
	STATUS_ERR_NOTANTRIEB:			BYTE := 103; (* Endschalter Notantrieb betätigt *)

	(* Fehlerzustände in Schrittkette *)
	(* Definitionen: *)
	(* Position U: Parameter Masthöhe untere Position *)
	(* Position E: Parameter Masthöhe untere Position + Parameter Fenster unterer Endschalter *)
	(* Position S: Parameter Masthöhe untere Position + Parameter Offset untere Position *)
	(* Position A: Parameter Masthöhe obere Position - Parameter Mast oben Absetzen Offset *)
	(* Position O: Parameter Masthöhe obere Position *)
	(* Es muss gelten: Position U < Position E < Position S < Position A < Position O *)
	STATUS_ERR_SET_FU_POS: 			BYTE := 110; (* Fehler beim Setzen der Nullposition im FU, FU-Position springt nicht auf eingestellten Wert *)
	STATUS_ERR_CURRENT_BOTTOM: 		BYTE := 111; (* Bei langsamer Fahrt niedriger Grenzwert Strom überschritten *)

	STATUS_ERR_ES_UNTEN_AUSFAHREN1:	BYTE := 120; (* Beim Ausfahren Endschalter suchen: Endschalter UNTEN unterhalb Position S nicht gefunden *)
	STATUS_ERR_ES_UNTEN_AUSFAHREN2:	BYTE := 121; (* Beim Ausfahren: Endschalter UNTEN oberhalb Position E betätigt *)
	STATUS_ERR_ES_FREIG_AUSFAHREN1:	BYTE := 123; (* Beim Ausfahren auf Position O: Endschalter AUFGERICHTET nicht mehr betätigt *)

	STATUS_ERR_ES_UNTEN_ABSETZEN:	BYTE := 130; (* Beim Einfahren in Position A: Endschalter UNTEN betätigt *)

	STATUS_ERR_ES_UNTEN_EINFAHREN1:	BYTE := 140; (* Beim Einfahren auf Position S: Endschalter UNTEN betätigt *)
	STATUS_ERR_ES_UNTEN_EINFAHREN2:	BYTE := 141; (* Bei Schleichfahrt auf Position U: Endschalter UNTEN nicht gefunden *)
	STATUS_ERR_ES_UNTEN_EINFAHREN3:	BYTE := 142; (* Bei Schleichfahrt auf Position U: Endschalter UNTEN unterhalb Position E nicht mehr betätigt *)

END_VAR

(* @END_DECLARATION := '0' *)


(******************* Diverse Timer *******************)
tonSystemEin(IN := TRUE, PT := T#1000ms);
tofInit(IN := init, PT := T#3s);
rtSystemEin(CLK := NOT tofInit.Q);
blnk(ENABLE := TRUE, TIMELOW := T#200ms, TIMEHIGH := T#200ms);

(******************* Initialisierungen *******************)
outputs.RelaisMotorLeistung := FALSE;
FU1_QSCmd := QSCMD_HALT;
masthoeheSchleichfahrt := Mast1BottomPosition + Mast1BottomPositionOffset;
masthoeheEndschalter := Mast1BottomPosition + Mast1BottomLimitSwitchWindow;
masthoeheAbsetzen := Mast1TopPosition - Mast1TopSettlingOffset;

IF NOT SIMULATIONSMODUS THEN
	masthoeheReal := DINT_TO_REAL(FU1_Position) * FU1_POS_TO_MM;
	Mast1Height := REAL_TO_WORD(masthoeheReal);
	Mast1Current := FU1_Current/1000;
ELSE
	Mast1Current := FU1_Current_Sim;
END_IF
Mast1FUErrorCode := FU1_ErrorCode;
Mast1Speed := FU1_Velocity;

(******************* Taste Reset *******************)
rtTasteReset(CLK := tasteReset);
IF rtTasteReset.Q THEN
	Mast1ErrorECU2PC := 0;
	IF mastPosGueltig THEN
		Status := STATUS_IDLE;
	ELSE
		Status := STATUS_INIT;
	END_IF
END_IF

(******************* Flag Mast-Position korrekt falls Endschalter betätigt und Masthöhe plausibel *******************)
(******************* -> Fehlermeldung Masthöhe unterdrücken, keine Nullfahrt notwendig *******************)
IF rtSystemEin.Q THEN
	mastPosGueltig := inputs.EndschalterEingefahren AND ABS_DIFF(Mast1Height, Mast1BottomPosition) <= 2;
END_IF

(******************* Fehlermeldungen *******************)
IF NOT canNodeFU1Present AND NOT tofInit.Q AND NOT SIMULATIONSMODUS THEN
	Mast1ErrorECU2PC.ECU2PC_ErrorCanTimeout := TRUE;
	Status := STATUS_ERR_FU_TIMEOUT;
END_IF

(* Auswertung FU Fehlercode *)
(* -710 -> Position unbekannt *)
(* -711 -> Positionswert ungültig *)

errorCode71x := FU1_ErrorCode = -710 OR FU1_ErrorCode = -711;

IF canNodeFU1Present AND tonSystemEin.Q AND FU1_ErrorCode <> 0 THEN
	Mast1ErrorECU2PC.ECU2PC_ErrorFU := TRUE;
	Status := STATUS_ERR_FU;
	IF errorCode71x THEN
		mastPosGueltig := FALSE;
	END_IF
END_IF

(******************* Fehler *******************)
IF ABS(Mast1Current) > Mast1CurrentLimit THEN
	Status := STATUS_ERR_CURRENT;
END_IF

(******************* Notantrieb/Handkurbel *******************)
IF inputs.EndschalterNotantrieb THEN
	Status := STATUS_ERR_NOTANTRIEB;
	mastPosGueltig := FALSE;
END_IF

(******************* Schrittkette *******************)
CASE status OF
	STATUS_INIT:
		Status := STATUS_WAIT_FOR_CAN_CLIENTS;
		TSStart := PLC_CYCLE.cycle;

	STATUS_WAIT_FOR_CAN_CLIENTS:
		(* Warten bis FU online ist *)
		FU1_QSCmd := QSCMD_CLEAR_ERROR;
		IF canNodeFU1Present OR SIMULATIONSMODUS THEN
			Status := STATUS_SUCCESS;
			TSStart := PLC_CYCLE.cycle;
		ELSIF PLC_CYCLE.cycle - TSStart > 20*_100ms THEN
			Status := STATUS_ERR_FU_TIMEOUT;
		END_IF

	STATUS_SUCCESS:
		(* Falls Endschalter EIN und Position plausibel -> normal Starten *)
		(* Sonst Nullfahrt nach oben bzw. unten *)
		IF inputs.EndschalterEingefahren AND ABS_DIFF(Mast1Height, Mast1BottomPosition) <= 2 THEN
			Status := STATUS_EINGEFAHREN;
		ELSIF inputs.EndschalterEingefahren THEN
			Status := STATUS_NULLFAHRT_AUSFAHREN;
		ELSE
			Status := STATUS_NULLFAHRT_EINFAHREN;
		END_IF

	STATUS_NULLFAHRT_AUSFAHREN:
		IF ABS(Mast1Current) > Mast1CurrentLimitBottom THEN
			(* Stromüberwachung unten *)
			Status := STATUS_ERR_CURRENT_BOTTOM;
		ELSIF tasteAuf THEN
			IF NOT inputs.EndschalterEingefahren THEN
				(* Endschalter unten erreicht, Nullpunkt setzen *)
				Status := STATUS_NULLPUNKT_SETZEN_INIT;
			ELSE
				(* Ausfahren im Geschwindigkeitsmodus *)
				(* Velocity mode: pos = auffahren, neg = einfahren oder umgekehrt je nach Vorzeichen Umrechnungsfaktor *)
				IF FU1_POS_TO_MM > 0 THEN
					FU1_QSData0 := Mast1VelocityBottom;
				ELSE
					FU1_QSData0 := -Mast1VelocityBottom;
				END_IF
				FU1_QSCmd := QSCMD_VELOCITY_MODE;
			END_IF
		END_IF

	STATUS_NULLFAHRT_EINFAHREN:
		IF ABS(Mast1Current) > Mast1CurrentLimitBottom THEN
			(* Stromüberwachung unten *)
			Status := STATUS_ERR_CURRENT_BOTTOM;
		ELSIF tasteAb THEN
			IF inputs.EndschalterEingefahren THEN
				(* Endschalter unten erreicht, Nullpunkt setzen *)
				Status := STATUS_NULLPUNKT_SETZEN_INIT;
			ELSE
				(* Einfahren im Geschwindigkeitsmodus *)
				(* Velocity mode: pos = auffahren, neg = einfahren oder umgekehrt je nach Vorzeichen Umrechnungsfaktor *)
				IF FU1_POS_TO_MM > 0 THEN
					FU1_QSData0 := -Mast1VelocityBottom;
				ELSE
					FU1_QSData0 := Mast1VelocityBottom;
				END_IF
				FU1_QSCmd := QSCMD_VELOCITY_MODE;
			END_IF
		END_IF

	STATUS_NULLPUNKT_SETZEN_INIT:
		(* Initialisierung Nullpunkt setzen, Mast stoppen *)
		status := STATUS_NULLPUNKT_SETZEN;
		TSStart := PLC_CYCLE.cycle;
		FU1_QSCmd := QSCMD_QUICK_STOP;

	STATUS_NULLPUNKT_SETZEN:
		(* Nach 500ms Nullpunkt in FU schreiben *)
		FU1_QSCmd := QSCMD_QUICK_STOP;
		IF PLC_CYCLE.cycle - TSStart > 5*_100ms THEN
			(* Masthöhe für Endschalter-Position in FU schreiben *)
			DWORD_TO_BYTES(
				dw := REAL_TO_DINT((masthoeheEndschalter)/FU1_POS_TO_MM),
				ll => SDOData[0],
				ml => SDOData[1],
				mh => SDOData[2],
				hh => SDOData[3]);
			TSStart := PLC_CYCLE.cycle;
			status := STATUS_WRITE_OFFSET;
		END_IF

	STATUS_WRITE_OFFSET:
		(* 500ms warten, dann prüfen ob Masthöhe Endschalter-Position entspricht *)
		IF PLC_CYCLE.cycle - TSStart > 5*_100ms THEN
			(* Fehlermeldung Mastposition zurücksetzen *)
			IF Mast1Height = masthoeheEndschalter OR SIMULATIONSMODUS THEN
				(* statusOffset := STATUS_SETUP_SAVE; 'save' nicht mehr an FU schicken *)
				status := STATUS_IDLE;
				mastPosGueltig := TRUE;
			ELSE
				status := STATUS_ERR_SET_FU_POS;
				CASE SDOWriteOffset.RESULT OF
					1: (* FB-Ausführung wurde ohne Fehler beendet, Daten sind gültig *)
						Mast1SetEncoderPW := 102;
					32: (* SDO-Übertragung abgebrochen von Client oder Server *)
						Mast1SetEncoderPW := 103;
					33: (* TIMEOUT ist abgelaufen *)
						Mast1SetEncoderPW := 104;
					242: (* Fehler: Einstellung ist nicht möglich *)
						Mast1SetEncoderPW := 105;
					ELSE
						Mast1SetEncoderPW := 106;
				END_CASE
			END_IF
		END_IF

	STATUS_IDLE:
		(* Startpunkt für Mast auf/ab fahren *)
		IF tasteAuf THEN
			IF inputs.EndschalterEingefahren THEN
				Status := STATUS_AUSFAHREN_ES_SUCHEN;
			ELSIF inputs.EndschalterAufgerichtet THEN
				Status := STATUS_AUSFAHREN;
			ELSE
				Status := STATUS_AUSFAHREN_MONTAGE;
			END_IF
		ELSIF tasteAb THEN
			IF Mast1Height > masthoeheSchleichfahrt THEN
				Status := STATUS_EINFAHREN;
			ELSIF NOT inputs.EndschalterEingefahren THEN
				Status := STATUS_SCHLEICHFAHRT_ES_SUCHEN;
			ELSE
				Status := STATUS_SCHLEICHFAHRT;
			END_IF
		END_IF

	STATUS_AUSFAHREN, STATUS_AUSFAHREN_ES_SUCHEN:
		IF NOT tasteAuf THEN
			(* Taste nicht mehr gedrückt? *)
			Status := STATUS_IDLE;
		ELSIF status = STATUS_AUSFAHREN_ES_SUCHEN AND Mast1Height >= masthoeheSchleichfahrt THEN
			(* Endschalter unten AUS oberhalb Position Schleichfahrt *)
			Status := STATUS_ERR_ES_UNTEN_AUSFAHREN1;
		ELSIF status = STATUS_AUSFAHREN_ES_SUCHEN AND NOT inputs.EndschalterEingefahren THEN
			(* Endschalter unten erreicht -> Nullpunkt setzen *)
			Status := STATUS_NULLPUNKT_SETZEN_INIT;
		ELSIF status = STATUS_AUSFAHREN AND inputs.EndschalterEingefahren THEN
			(* Endschalter unten EIN oberhalb Position Endschalter *)
			Status := STATUS_ERR_ES_UNTEN_AUSFAHREN2;
		ELSIF status = STATUS_AUSFAHREN AND NOT inputs.EndschalterAufgerichtet THEN
			(* Endschalter aufgerichtet AUS bei Fahrt auf obere Position *)
			Status := STATUS_ERR_ES_FREIG_AUSFAHREN1;
		ELSIF Mast1Height >= Mast1TopPosition THEN
			(* Obere Position erreicht -> Absetzen *)
			Status := STATUS_ABSETZEN_INIT;
		ELSE
			(* Bei Suche ES langsam fahren, sonst normale Geschwindigkeit *)
			IF status = STATUS_AUSFAHREN THEN
				FU1_QSData0 := Mast1VelocityNormal;
			ELSE
				FU1_QSData0 := Mast1VelocityBottom;
			END_IF
			(* Positionieren auf obere Position *)
			FU1_QSData1 := REAL_TO_DINT(WORD_TO_REAL(Mast1TopPosition)/FU1_POS_TO_MM);
			FU1_QSCmd := QSCMD_ABS_POS_MODE;
		END_IF

	STATUS_ABSETZEN_INIT:
		Status := STATUS_ABSETZEN;
		TSStart := PLC_CYCLE.cycle;

	STATUS_ABSETZEN:
		(* Automatische Fahrt, Taste nicht abfragen *)
		IF inputs.EndschalterEingefahren THEN
			(* Endschalter unten EIN bei Fahrt auf Absetzposition *)
			Status := STATUS_ERR_ES_UNTEN_ABSETZEN;
		ELSIF Mast1Height <= masthoeheAbsetzen THEN
			(* Absetzposition erreicht *)
			Status := STATUS_AUSGEFAHREN;
		ELSE
			(* Positionieren auf Absetzposition mit normaler Geschwindigkeit *)
			FU1_QSData0 := Mast1VelocityBottom;
			FU1_QSData1 := REAL_TO_DINT(WORD_TO_REAL(masthoeheAbsetzen)/FU1_POS_TO_MM);
			FU1_QSCmd := QSCMD_ABS_POS_MODE;
		END_IF

	STATUS_AUSGEFAHREN:
		IF tasteAb THEN
			Status := STATUS_IDLE;
		END_IF

	STATUS_AUSFAHREN_MONTAGE:
		IF NOT tasteAuf THEN
			(* Taste nicht mehr gedrückt? *)
			Status := STATUS_IDLE;
		ELSIF inputs.EndschalterEingefahren THEN
			(* Endschalter EIN oberhalb Höhe Endschalter *)
			Status := STATUS_ERR_ES_UNTEN_AUSFAHREN2;
		ELSIF Mast1Height >= Mast1MontagePos THEN
			(* Montageposition erreicht *)
			Status := STATUS_MONTAGEPOSITION;
		ELSE
			(* Positionieren auf Montageposition mit normaler Geschwindigkeit *)
			FU1_QSData0 := Mast1VelocityNormal;
			FU1_QSData1 := REAL_TO_DINT(WORD_TO_REAL(Mast1MontagePos)/FU1_POS_TO_MM);
			FU1_QSCmd := QSCMD_ABS_POS_MODE;
		END_IF

	STATUS_MONTAGEPOSITION:
		IF tasteAb THEN
			Status := STATUS_IDLE;
		END_IF

	STATUS_EINFAHREN:
		IF NOT tasteAb THEN
			(* Taste nicht mehr gedrückt? *)
			Status := STATUS_IDLE;
		ELSIF inputs.EndschalterEingefahren THEN
			(* Endschalter unten EIN oberhalb Position Schleichfahrt *)
			Status := STATUS_ERR_ES_UNTEN_EINFAHREN1;
		ELSIF Mast1Height <= masthoeheSchleichfahrt THEN
			(* Position Schleichfahrt erreicht *)
			Status := STATUS_IDLE;
		ELSE
			(* Positionieren auf Position Schleichfahrt mit normaler Geschwindigkeit *)
			FU1_QSData0 := Mast1VelocityNormal;
			FU1_QSData1 := REAL_TO_DINT(WORD_TO_REAL(masthoeheSchleichfahrt)/FU1_POS_TO_MM);
			FU1_QSCmd := QSCMD_ABS_POS_MODE;
		END_IF

	STATUS_SCHLEICHFAHRT_ES_SUCHEN, STATUS_SCHLEICHFAHRT:
		IF ABS(Mast1Current) > Mast1CurrentLimitBottom THEN
			(* Stromüberwachung unten *)
			Status := STATUS_ERR_CURRENT_BOTTOM;
		ELSIF NOT tasteAb THEN
			(* Taste nicht mehr gedrückt? *)
			Status := STATUS_IDLE;
		ELSIF Mast1Height <= Mast1BottomPosition THEN
			(* Untere Position erreicht *)
			IF status = STATUS_SCHLEICHFAHRT THEN
				Status := STATUS_EINGEFAHREN;
			ELSE
				(* Endschalter unten nicht erreicht *)
				Status := STATUS_ERR_ES_UNTEN_EINFAHREN2;
			END_IF
		ELSIF status = STATUS_SCHLEICHFAHRT_ES_SUCHEN AND inputs.EndschalterEingefahren THEN
			(* Endschalter unten erreicht, Nullpunkt setzen *)
			Status := STATUS_NULLPUNKT_SETZEN_INIT;
		ELSIF status = STATUS_SCHLEICHFAHRT AND NOT inputs.EndschalterEingefahren THEN
			(* Endschalter unten AUS nach Suche ES *)
			Status := STATUS_ERR_ES_UNTEN_EINFAHREN3;
		ELSE
			(* Positionieren auf untere Position mit langsamer Geschwindigkeit *)
			FU1_QSData0 := Mast1VelocityBottom;
			FU1_QSData1 := REAL_TO_DINT(WORD_TO_REAL(Mast1BottomPosition)/FU1_POS_TO_MM);
			FU1_QSCmd := QSCMD_ABS_POS_MODE;
		END_IF

	STATUS_EINGEFAHREN:
		IF tasteAuf THEN
			Status := STATUS_IDLE;
		END_IF

END_CASE

(******************* Schrittkette in Fehlerzustand *******************)
Mast1ErrorECU2PC.ECU2PC_ErrorMastSchrittkette := (Status >= 100);

(******************* FU-Fehler zurücksetzen *******************)
IF tasteReset (* OR errorCode71x *) OR NOT tonSystemEin.Q AND blnk.OUT THEN
	FU1_QSCmd := QSCMD_CLEAR_ERROR;
END_IF

(******************* K1 Versorgung Motor *******************)
IF NOT inputs.EndschalterNotantrieb THEN
	outputs.RelaisMotorLeistung := TRUE;
END_IF

(******************* SDO-Befehle *******************)
SDOWriteOffset(
	EXECUTE := status = STATUS_WRITE_OFFSET,
	CHANNEL := CAN_CHANNEL_LOCAL,
	NODE := FU1_NODE_ID,
	IDX := 16#4762,
	SUBIDX := 1,
	LEN := 4,
	DATA := SDOData,
	Timeout := T#200ms,
	RESULT => );


END_PROGRAM
